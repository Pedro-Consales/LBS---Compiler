# LBS---Compiler
LBS is a generic programming language that needed to be compiled for an assignment at PUC-Rio; this repository contains a C implementation of a JIT-style compiler/runner for that language.

## Architecture and goal
- **Front-end:** `main_comp.c` is a small driver that opens an LBS source file, reads an optional integer argument, and delegates translation to `gera_codigo` before invoking the generated function pointer.
- **Code generator:** `gera_codigo.c` implements `gera_codigo(FILE *f, unsigned char code[], funcp *entry)`, which parses each instruction in the simplified LBS language and emits raw x86-64 machine code into the provided `code` buffer. It builds activation records for up to five local variables (v0–v4), handles the single parameter `p0`, and supports arithmetic operations, conditional `zret` (zero-return) jumps, constant returns, and nested `call` invocations between functions defined in the same input file. A linked list of function descriptors tracks the code offsets for each `function ... end` block so that later `call` sites can compute relative displacements.
- **Runtime:** The emitted buffer is marked executable (via the assembler flag) so the program can cast it to `funcp` and run it directly, providing a minimal JIT experience without writing temporary object files.

## Environment and dependencies
- GCC targeting x86-64 Linux with support for inline machine code emission.
- Executable stack enabled when assembling, because the generated bytes are executed directly from the writable buffer.

### Build
Compile the driver and generator together, requesting an executable stack:

```bash
gcc -Wall -Wa,--execstack -o yourprogram_exe main_comp.c gera_codigo.c
```

### Run
Execute by passing the LBS source path and, optionally, the integer argument consumed as `p0`:

```bash
./yourprogram_exe "arqvname"
./yourprogram_exe "arqvname" p0
```

## Available test programs
Each `ex*.txt` file holds a standalone LBS program that you can feed to the compiler:

- **`ex1_lbs.txt`** – Single function returning the constant 100 via `ret $100` for a zero-argument program.

- **`ex2_lbs_ret_constante.txt`** – Adds a constant (100) to zero and returns the result, exercising variable assignment and `ret v0`.

- **`ex3_lbs_func.txt`** – Demonstrates parameter usage: computes `p0 + 1` and returns it.

- **`ex4_lbs_count_combination.txt`** – Performs a two-step arithmetic expression: doubles `p0`, adds 3, and returns the sum.

- **`ex5_lbs_zret_cost.txt`** – Uses `zret` to return 42 when `p0 + 0` equals zero; otherwise returns 99, showing conditional early exit.

- **`ex6_lbs_fat.txt`** – Recursive factorial-like pattern: base case returns 1 when `p0` is zero, otherwise decrements `p0`, recursively calls itself, multiplies, and returns the product.

- **`ex7_lbs_call_const_chain.txt`** – Two functions: the first returns `7 + 0`, the second calls the first, adds the argument again, and returns, illustrating cross-function calls.

- **`ex8_lbs_sqaure_sum.txt`** – Two functions implementing square-and-sum: function 0 squares its input; function 1 checks for zero, decrements, recursively sums previous square with current square, and returns the accumulated value.

Feed any of these paths to the compiled executable to validate the generator and runtime.
